### 事务隔离级别

- 4个隔离级别
  - Read uncommitted 读未提交
  - Read committed 读提交
  - Repeatable read 重复读 (MySQL默认隔离级别)
  - Serializable 序列化

<center>√: 可能出现</center>
<center>×: 不会出现</center>

|          | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 读未提交 |  √   |     √      |  √   |
|  读提交  |  ×   |     √      |  √   |
|  重复读  |  ×   |     ×      |  √   |
|  序列化  |  ×   |     ×      |  ×   |

#### 隔离级别

##### 未提交读 Read uncommitted

<u>不允许同时写</u>

- 允许脏读, 不允许更新丢失
- 不可同时写, 但写时允许读
- 通过"排他写锁"实现

##### 提交读 Read committed

<u>写时不允许读写</u>

- 不允许脏读, 允许不可重复读
- 未提交的写事务禁止其他事务访问对应数据, 读事务时允许其他事务访问
- 通过"瞬间共享锁"和"排他写锁"实现

##### 重复读 Repeatable read

<u>只能同时读</u>

- 不允许不可重复读和脏读, 可能出现幻读
- 读取数据时禁止写事务, 写时禁止其他任何事务

##### 串行化 Serializable

<u>任何情况的读写都不能同时进行</u>

#### 解决的问题

##### 脏读

事务A正在访问并修改数据，尚未将修改结果提交给数据库；事务B也访问并使用了原始数据

##### 不可重复读

一个事务多次读取同一记录，得到的结果不一致. 比如事务A两次读取同一文档, 在两次读取之间文档被其他事物修改, 导致两次读取不一致. 

##### 幻读

事务A对表中数据做了修改, 涉及到表中全部数据行. 同时, 事务B修改表中数据, 这种修改是向表中插入一行新数据. 那么, 事务A用户就会发现表中还有没被修改过的数据行, 就像出现幻觉一样.

幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行

> 幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。
>
> 更为具体一些：<u>select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</u>
>
> 幻读错误的理解：说幻读是 事务A 执行两次 select 操作得到不同的数据集，即 select 1 得到 10 条记录，select 2 得到 11 条记录。这其实并不是幻读，这是不可重复读的一种，只会在 R-U R-C 级别下出现，而在 mysql 默认的 RR 隔离级别是不会出现的。



Q: <u>可重复读级别下，两个事务并发读取一个 i=1，并且i++，最终结果是什么</u>



### 悲观锁、乐观锁



### 唯一索引、主键、二者区别

##### 唯一索引

- 唯一索引不允许两行具有相同的索引值。
- 如果现有数据中存在重复的键值，则大多数数据库都不允许将新创建的唯一索引与表一起保存。当新数据将使表中的键值重复时，数据库也拒绝接受此数据。例如，如果在employee 表中的职员姓氏(lname) 列上创建了唯一索引，则所有职员不能同姓。

##### 主键索引

- 主键既是约数也是索引。
- 主键索引是唯一索引的特殊类型。
- 数据库表通常有一列或列组合，其值用来唯一标识表中的每一行。该列称为表的主键。
- 在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。

##### 二者区别

- 对于主健/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引；
- 主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的；
- 主健可作外健，唯一索引不可；
- 主健不可为空，唯一索引可；
- 主健也可是多个字段的组合；
- 主键与唯一索引不同的是：
  - 有not null属性；
  - 每个表只能有一个。



### 数据库引擎



### 数据库引擎innoDB和MyISAM区别

1. InnoDB 支持**事务**，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持**外键**，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  
3. InnoDB 是**聚集索引**，MyISAM 是非聚集索引。
   - 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
   - MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
4. InnoDB 不**保存表的具体行数**，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    
5. InnoDB **最小锁粒度**是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

>**如何选择：**
>
>1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；
>2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果写也挺频繁，请使用InnoDB。
>3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；
>4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。



### MVCC的实现
### 索引原理
### innodb主键自增为什么 有什么好处




### 事务 ACID

- **A** : 事务的**原子性**(Atomicity)

  - 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。

- **C **: 事务的**一致性**(Consistency)

  - 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。
  - 指事务的运行并不改变数据库中数据的一致性. 比如A转100元给B，A扣减100，B加上100，在事务开始前和事务完成之后都能保证他们的帐是对上的，那么这就是事务一致性。但是在事务过程中有可能会出现A扣减了100元，B没有加上100元的情况，这就是不一致。

  > 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

- **I** : **独立性**(Isolation）

  - 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
  - 事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。

- **D** : **持久性**(Durability）

  - 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失.



### 聚簇索引和普通索引

##### 聚簇索引

- 聚簇索引的叶子节点就是数据节点
- innoDB按聚簇索引的形式存储数据
- 优缺点：
  - 优点：
    1. 当需要取出一定范围内的数据时，用聚簇索引比用非聚簇索引好。
    2. 通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。
    3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
  - 缺点：
    1. **插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。
    2. **更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。
    3. **二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。
    4. **采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。

##### 非聚簇索引

- 非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针
- MyISAM按非聚簇索引的形式存储数据
  - 因此，MYISAM引擎的索引文件（.MYI）和数据文件(.MYD)是相互独立的

![img](https://user-gold-cdn.xitu.io/2019/5/16/16ac10253b8748df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 联合索引



### 数据库最左前缀匹配原则

- 在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配

- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式



### B+树和hash哪个适合做索引

##### B+树

B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，遍历树的节点，因此查询、插入、修改、删除的平均时间复杂度是 O(lg(n))。

##### hash

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位。因此查询、插入、修改、删除的平均时间复杂度是 O(1)。

##### 为什么选用B+树

对于一条单行查询的 SQL，确实哈希索引更快，应为只查询一条记录，哈希检索可以一次定位。

但是关系型数据库更多的需求像下面：

- 分组：group by
- 排序： order by
- 比较： <、>
- ......

在这样的查询需求下，哈希型的索引的时间复杂度会变成O(n),而树型索引的有序特性，依然能够保持 O(log(n))的高效率。因此数据库选择树结构实现。

 



总结：后端岗貌似很喜欢对数据库层次进行疯狂追问，什么范式，事务貌似都是简单到不会问的题了

面试官问我硬件题，我都怀疑我面得是后端吗？