### 1 数组和链表的区别

#### 1.1 数组

- 内存连续, 定义时就需要预留空间
- 插入删除为O(n), 效率低
- 随机读取效率高, 直接根据索引读内存即可
- 不利于扩展, 初始定义的空间不够时需要重新定义数组

#### 1.2 链表

- 内存不连续
- 插入删除为O(1), 效率高
- 随机读取/查找效率低, 不具有随机访问性, 必须按顺序找
- 不指定大小, 扩展方便



### 2 快排

#### 最好最差情况



1. 哈希表原理，常见碰撞算法（解决冲突的方法）
   - 碰撞算法：
     - 再散列法
       - 线性探测再散列
       - 二次探测再散列
       - 随即探测再散列
     - 再哈希法：使用第二个、第三个、……哈希函数再次计算地址，直到没有冲突
     - 拉链法
     - 设置公共溢出区
2. hashmap设计及存在相同key的时候的解决方法
3. 平衡二叉树



### 3 如何判断一个二叉树是否是二叉搜索树

#### 3.1 二叉搜索树的定义

- 节点的左子树中任意节点值小于根节点
- 节点的右子树中任意节点值大于根节点
- 左右子树都必须是二叉查找树，不允许存在重复节点。

#### 3.2 判断二叉搜索树的算法

##### 利用中序遍历

对树进行中序遍历, 得到的数组若为升序, 则树为二叉搜索树

(可以不用数组, 只保存前驱节点, 若前驱节点大于当前节点, 则返回假)



### 4 C++中delete a和delete[] a的区别

- delete 回收单个对象内存空间
- delete[] 回收一组对象内存空间, 分为两种情况
  - 为基本数据类型回收空间
  - 为自定义类型回收空间
- 析构函数调用区别:
  - delete a释放a指针指向的全部内存空间, 但只调用a[0]对象的析构函数
  - delete[] a释放a指针指向的内存空间, 并逐一调用数组中每个对象的析构函数
  - 因此, 对于int/char/struct等简单数据类型, 由于对象没有析构函数, 二者没有差别
  - 但对于有析构函数的对象, 例如自定义类, delete a只能释放对象本身占用的存储空间, 而不调用逐一析构函数, 如果该类占用了操作系统资源, 如套接字文件线程等, 不析构会导致资源一直被占用, 无法释放



### 5 有环链表的判断 和  环长度判断

快慢指针



