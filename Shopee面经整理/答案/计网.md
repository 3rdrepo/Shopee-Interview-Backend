## 1. ping网站所用的协议

通过**DNS协议**，将ping后接的域名转换为IP地址。（DNS使用的传输层协议是**UDP**）

通过**ARP解析服务**，由IP地址解析出MAC地址，以在数据链路层传输。

ping是为了测试另一主机是否可达，发送一份**ICMP（Internet控制报文协议）**回显请求给目标主机，等待ICMP回显应答。

- 跟踪路由的trancert命令也基于ICMP协议

![这里写图片描述](https://img-blog.csdn.net/20170822224933262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 详细过程

##### 查IP

1、主机查找本地系统Hosts文件的DNS缓存，如果存在该域名对应的IP，则获取IP，跳转到第8步；如果不存在，则继续。

2、主机向本网络路由器发起请求，查找路由DNS缓存，如果存在该域名对于的IP，则获取IP，跳转到第8步；如果不存在，则继续。

3、路由器向本地ISP（互联网提供商）的DNS服务器发起请求，查找DNS服务器的缓存，如果存在该域名对应的IP，则跳转到第7步；如果不存在，则继续。

4、本地DNS服务器向根域名服务器发起请求，根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。

5、本地域名服务器向顶级域名服务器dns.com进行查询，顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。

6、本地域名服务器向权限域名服务器dns.abc.com进行查询，权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。 

7、本地域名服务器最后把查询结果——该域名对应的IP地址告诉给主机。

8、至此，主机知道了该域名的IP地址。

----------------------------------------------------------------------------------------

##### 查MAC

9、主机通过子网掩码判断该IP地址是本网段还是跨网段，由于本网段比较简单，我们以跨网段进行讲解。

10、主机先查看本地ARP高速缓存，查看表中是否有本网络路由器（网关）的MAC地址，如果有，则获取MAC地址，跳转到第12步；如果没有，则继续。

11、主机使用ARP解析协议获取到本网段路由的MAC地址。

12、至此，主机知道本网络一个路由的MAC地址。

----------------------------------------------------------------------------------------

##### ping

13、主机将ICMP报文封装成IP数据报，IP数据报的源地址为主机的IP地址，目的地址是域名对应的IP地址；

14、主机将IP数据报封装成MAC帧，MAC帧的源地址为主机的MAC地址，目的地址是路由器的MAC地址；

12、路由器接收到ICMP报文之后，发现MAC帧的目的地址是自己，IP地址是主机想要访问的IP地址，则将MAC帧的源地址改为自己的MAC地址，目的地址改为本网段另一个路由的MAC地址（也要通过ARP协议获取），转发下去...

13、直到最后一个路由根据ARP协议，找到了主机想要访问的IP地址对应的主机的MAC地址，然后将ICMP报文封装成MAC帧发送给该域名主机。

14、由于ARP协议具有相互学习性，域名主机接收到主机发送的ICMP回送请求报文之后，将向本网络路由发送ICMP回送回答报文，该路由又会转发下去...

15、当主机收到域名主机发送的ICMP回送回答报文之后，这样就表明该主机到域名主机是连通可达的。



## 2. 访问URL全过程

##### DNS解析

##### TCP连接

##### 发送http请求

##### 服务器处理请求并返回报文

##### 浏览器解析渲染页面

##### 断开连接：TCP四次挥手



## 3. TCP三次握手

- 在 socket 编程中，客户端执行 `connect()` 时，将触发三次握手。

![three-way-handshake](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

##### 第一次握手

- 客户端 → 服务器，发送连接请求报文
- SYN = 1, seq = x
-  发送完毕后，客户端进入 `SYN_SEND` 状态。

##### 第二次握手

- 服务器 → 客户端，发送确认报文
- SYN = 1, ACK = 1, seq = y, ack = x + 1
- 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

##### 第三次握手

- 客户端 → 服务器，发送确认报文
- SYN = 0, ACK = 1, ack = y + 1
-  发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

#### 为什么不能缩减为两次握手

- 因为有连接请求报文失效的情况
- 比如Client发送了一个请求报文，由于网络问题滞留在中间的某个网络节点，直到很久之后才到达Server，这是一个失效报文，但Server收到后仍然会回复确认报文。如果采用两次握手，Server确认后会一直等待Client发来数据，但Client并不会理会Server



## 4. TCP四次挥手

- 客户端和服务器端均可主动发起挥手
- socket编程中，任何一方执行`close()`操作即可触发挥手操作

![four-way-handshake](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

##### 第一次挥手

- FIN = 1, seq = x
-  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
-  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

##### 第二次挥手

- ACK = 1, ack = x + 1
-  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
-  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

##### 第三次挥手

- FIN = 1, seq = y
-  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
-  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

##### 第四次挥手

- ACK = 1, ack = y + 1
- 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。
- 服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。
- 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

### 为什么需要四次挥手

因为TCP是全双工模式。主机1发送FIN报文段，只表示主机1没有数据需要发送，相当于要求关闭单方数据通道；而主机2发送FIN报文段，才表示主机2也没有数据需要发送，可以关闭双方通道。



## 5. TCP的TIME_WAIT状态

![image-20200402152323309](C:\Users\84040\AppData\Roaming\Typora\typora-user-images\image-20200402152323309.png)

客户端“等待2MSL”期间即处于TIME_WAIT状态

#### TIME_WAIT状态

- TCP连接中，调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该**发送方会保持2MSL时间之后才会回到初始状态**。MSL值得是数据包在网络中的最大生存时间。
- 后果：在2MSL连接等待期间，本TCP连接定义的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。

#### TIME_WAIT状态的目的

1. 保证TCP全双工连接可靠释放

   假设主动关闭连接的一方（假设是客户端）最后发送的ACK报文在网络中丢失，服务器会重发FIN报文。在重发的FIN报文到达客户端之前，客户端必须维护连接状态，才能正常进行重传等工作。

   如果没有TIME_WAIT状态，那么当服务器重发的FIN报文到达时，客户端会用RST报文相应，这会让服务器认为出现了异常。

2. 使旧的数据包在网络中因过期而消失

   TCP连接由 (local_IP, local_port, remote_IP, remote port) 四元组唯一标识，现在假设TIME_WAIT状态不存在的情况：

   客户端主动关闭连接后，未经TIME_WAIT状态，直接重新和服务器再次建立一个新TCP连接，这个新连接的四元组和旧连接相同。如果旧连接的报文阻塞在网络中，直到建立新连接后才到达服务器，由于新旧TCP连接四元组相同，服务器会认为这个旧连接的报文是当前需要的报文，而将其向上传递给应用层，这就会造成数据错乱等问题，破坏TCP的可靠性。

   > 释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突

#### TIME_WAIT状态可能造成的问题

高并发短连接的情况下，会有大量socket处于TIME_WAIT状态。

- 高并发：短时间内同时占用大量端口
- 短连接：业务处理+数据传输时间远小于TIME_WAIT时间

持续高并发短连接，会导致服务器因资源不足拒绝服务。

##### 解决办法

- SO_REUSEADDR能避免TIME_WAIT状态，让端口释放后立刻就可以被再次使用
- 让短连接变为长连接



## 6. 端口号

#### 公认端口（0 ~ 1023）

- FTP : 21 
- TELNET : 23
- SMTP : 25
- DNS : 53
- TFTP : 69 
- HTTP : 80
- SNMP : 161

#### 注册端口（1024 ~ 49151）

#### 动态（临时）端口（49152~65535）



## 7. TCP和UDP

### TCP

- TCP 提供一种**面向连接的、可靠的**字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- **可靠传输**：校验和，确认和重传机制
- **有序性/非重复**：给数据分节进行排序，累积确认
- **流量控制**：滑动窗口
  - **流量控制指点对点通信量，作用于接收者，防止发送速度太快导致分组丢失**
  - 接收方维护接收窗口
  - 发送方维护拥塞窗口和发送窗口
  - 发送窗口 = min(接收窗口，拥塞窗口)
  - 接收方返回的 ACK 中会包含自己接收窗口的大小，并且利用大小来控制发送方的数据发送。
- **拥塞控制**：动态改变窗口大小
  - **拥塞控制是一个全局性的过程，作用于网络，防止网络负载过大导致拥塞**
  - 慢开始算法（cwnd<ssthresh）：指数增长
  - 拥塞避免算法（cwnd>ssthresh）：线性增长
  - 出现网络拥塞时（未收到确认）：
    - ssthresh = (1/2)cwnd
    - cwnd = 1
  - 快重传：
    - 接收方在收到失序报文后立刻发出重复确认（而非等到自己发送数据时捎带确认）
    - 发送方收到三个重复确认就立即重传对方未收到的报文（而不必等待重传计时器到期）
  - 快恢复：
    - 连续收到三个重复确认：ssthresh = (1/2)ssthresh
    - 因为能收到重复确认，所以认为网络没有拥塞，此时令cwnd = ssthresh，执行拥塞避免算法



### UDP

- <u>UDP 缺乏可靠性</u>。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次
- <u>UDP 数据报是有长度的</u>。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。
- <u>UDP 是无连接的</u>。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。
- <u>UDP 支持多播和广播</u>。



## 8. HTTP状态码

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误



## cookie和session的区别？

追问：session是如何识别用户的？（emm，我说了session id，面试官又追问id存在哪儿）
session id就是依靠cookie，在cookie中的



## 说一下https有什么加密方式（对称、非对称，只答了非对称），其如何传输公钥保证公钥不被截获

